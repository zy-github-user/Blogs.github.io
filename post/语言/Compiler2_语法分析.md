## 语法分析(Syntax Analysis)的任务

分析的任务是**确定程序的语法，或称作结构**，也正是这个原因，它又被称作**语法分析（syntax analysis）**。程序设计语言的语法通常是由**上下文无关（context-free grammar）**的**文法规则（grammar rule）**给出，其方式同扫描程序识别的由正则表达式提供的记号的词法结构相类似。上下文无关文法的确利用了与正则表达式中极为类似的命名惯例和运算。二者的主要区别在于上下文无关文法的规则是**递归的（recursive）**。例如一般来说，if 语句的结构应允许其中可嵌套其他的 if 语句，而在正则表达式中却不能这样做。这个区别造成的影响很大。由上下文无关文法识别的结构类比由正则表达式识别的结构类大大增多了。用作识别这些结构的算法也与扫描算法差别很大，这是因为它们必须使用递归调用或显式管理的分析栈。用作表示语言语义结构的数据结构现在也必须是递归的，而不再是线性的（如同用于词法和记号中的一样）了。经常使用的基本结构是一类树，称作**分析树（parse tree）**或**语法树（syntax tree）**。





输入记号流，语法规则，输出抽象语法树(分析语法错误也是这部分职责)

![](img/2ast.png)

## 上下文无关文法

**context-free grammar**，描述语法规则的数学工具



上下文无关文法说明程序设计语言的语法结构。除了上下文无关文法涉及到了递归规则之外，这样的说明与使用正则表达式的词法结构的说明十分类似：
$$
exp \to exp\  op\  exp |(exp)|number \\
op\to +|-|*
$$


同正则表达式类似，文法规则是定义在一个字母表或符号集之上。在正则表达式中，这些符号通常就是字符，而在文法规则中，符号通常是表示字符串的记号。选择并置操作与正则表达式一样，但是重复操作使用递归表示，而不是像正则那样$a^*$表示。箭头符号“→”来表示名字的定义





 **上下文无关文法**是四元组$G(V_T,V_N,S,P)$：



* $V_T$：终结符集合
* $V_N$：非终结符集合
* $S$：开始符号，非终结符中的一个
* $P$：产生式集合，产生式形式：$A\to\alpha$





**推导**：



* 给定文法$G$，从G的开始符号S开始，用产生式的右部替换左侧的**非终结符**
* 不断重复，直到不出现**非终结符**为止
* 最终的串称为**句子**



**最左推导**：每次总是选择最左侧的符号进行替换



**最右推导**：每次总是选择最右侧的符号进行替换



## 分析树与抽象语法树

推导 为 构造 来自一个初始的非终结符的特定终结符的串 提供了一个办法，但是推导并未唯一地表示出它们所构造的结构。总而言之，对于同一个串可有多个推导。
$$
exp \to exp\  op\  exp |(exp)|number \\
op\to +|-|*
$$
对于上面的文法，我们构造出记号串 $(numver\ -\ number)\ *\ number$，下面两种推导都可以


$$
exp \Rightarrow exp\ op\ exp\\
\Rightarrow exp\ op\ number\\
\Rightarrow exp\ *\ number\\
\Rightarrow (exp)\ *\ number\\
\Rightarrow (exp\ op\ exp)\ *\ number\\
\Rightarrow (exp\ op\ number)\ *\ nummber\\
\Rightarrow (exp\ -\ number)\ *\ nummber\\
\Rightarrow (number\ -\ number)\ *\ nummber\\
$$


$$

exp \Rightarrow exp\ op\ exp\\
\Rightarrow (exp)\ op\ exp\\
\Rightarrow (exp\ op\ exp)\ op\ exp\\
\Rightarrow (number\ op\ exp)\ op\ exp\\
\Rightarrow (number\ -\ exp)\ op\ exp\\
\Rightarrow (number\ -\ number)\ op\ exp\\
\Rightarrow (number\ -\ number)\ *\ exp\\
\Rightarrow (number\ -\ number)\ *\ number\\
$$





二者唯一的差别在于提供的替换顺序，而这其实是一个很表面的差别。为了把它表示得更清楚一些，我们需要表示出终结符串的结构，而这些终结符将推导的主要特征抽取出来，同时却将表面的差别按顺序分解开来。这样的表示法就是树结构，它称作**分析树**。



一个例子：推导与**分析树**



![](img/tdandast.png)





**抽象语法树**：

分析树是表述记号串结构的一种十分有用的表示法。在分析树中，记号表现为分析树的树叶（自左至右），而分析树的内部节点则表示推导的各个步骤（按某种顺序）。但是，分析树却包括了比纯粹为编译生成可执行代码所需的更多的信息。为了看清这一点，可根据简单的表达式文法，考虑表达式 $3 + 4$ 的分析树：

![](img/3+4.png)

实际上可将这个树看作：根代表两个孩子 $exp$子树的数值相加。而另一方面，每个子树又代表它的每个 $number$孩子的值。但是还有一个更为简单的方法能表示与这相同的信息，即如树：

![](img/3+4ast.png)







例2：$(34-2)*42$

![](img/34-2.png)



![](img/34-2ast.png)





在这个树中，括号记号实际已消失了，但它仍然准确地表达着从 34中减去3，然后再乘以42的语义内容。



这种树是真正的源代码记号序列的抽象表示。虽然不能从其中重新得到记号序列（不同于分析树），但是它们却包含了转换所需的所有信息，而且比分析树效率更高。这样的树称作**抽象语法树（abstract syntax tree）**或简称为**语法树（syntax tree）**。



一般树的含义取决于后序遍历，这会引出二义性文法



## 二义性文法

给定文法 $G$，如果存在句子 $s$，他有两颗不同的分析树，那么称 $G$ 为二义性文法。（因为如果树结构不同，那么后续遍历结果肯定不同，产生歧义）



解决方案：**重写**，具体问题具体分析，没有统一方法



二义性文法认为是一种语言语法的不完善说明，而且也应避免它。产生根本原因是文法中缺少对文法符号优先级和结合性的规定。



改写二义性闻法得关键步骤

* 一如一个新的非终结符，增加一个子结构，并提高一级优先级
* 递归非终结符在终结符左边，使该终结符具有左结合性，反之是右结合



## 自顶向下的分析

语法分析：给定文法$G$和句子$s$，回答$s$能否从$G$推导出来？（也就是输入是否合法）



基本算法思想：从$G$的开始符号出发，随意推导出某个句子$t$，比较$t$和$s$，相等回答yes，否则?(回溯，继续)，其实就等同于在树上做回溯遍历(一般是后序)



因为这是从开始符号出发推导出句子，因此称为**自顶向下分析**



回溯非常费时，我们需要线性时间的算法

* 避免回溯
  * 用前看符号避免回溯，选择产生式时候，看一眼输入的串当前该匹配哪个符号，找到准确路线(会有多个路线如何选择的问题)
* **引出递归下降分析算法**和**LL(1)分析算法**

### 递归下降分析算法

* 也称为预测分析
* 分析高效(线性时间)
* 容易实现(方便手工编码)
* 错误定位和诊断信息准确
* 被很多编译器采用：GCC4.0，LLVM ...





算法基本思想：分治

* 每个非终结符构造一个分析函数
* 用**前看符号**指导产生式规则的选择

![](img/dgxj.png)

![](img/dgxj_2.png)

### LL(1)分析算法

分析算法规范后，可以利用算法自动生成语法分析器的代码：比如一些工具

* ANTLR
* YACC
* bison



**LL(1)**分析算法：

* 从**左(L)**向右读入程序，最**左(L)**推导，采用**一个(1)**前看符号(用未读入的符号做辅助)
  * 分析高效(线性时间)
  * 错误定位和诊断信息准确
  * 有很多开源或商业生成工具：ANTLR...
* 基本思想：表驱动的分析算法



表驱动LL分析器架构：

![](img/l.png)



前面说自顶向下是遍历树，只使用栈会导致回溯，用分析表指导，避免回溯。



